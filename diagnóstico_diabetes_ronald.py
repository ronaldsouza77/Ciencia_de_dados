# -*- coding: utf-8 -*-
"""Diagnóstico diabetes_Ronald.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N3vBE15Ob2rHiR2vmA1WJkL2vZCTHzbZ

Minha solução em Python
"""

import pandas as pd

# Carregar o conjunto de dados
dados = pd.read_csv("/content/drive/MyDrive/diabetes.csv")
## display(dados)

from sklearn.model_selection import train_test_split

# Separação do conjunto de dados

# Obs: train_size e teste_size definem os tamanhos dos conjuntos de treino e teste.
# random_state garante que a divisão dos dados de treino e teste seja sempre a mesma a cada execução do código.
treino, teste = train_test_split(dados, train_size = 0.7, test_size = 0.3, random_state = 50)


from sklearn.svm import SVC
from sklearn.naive_bayes import GaussianNB

# Definindo os classificadores

# chamando os construtores das classes SVC e GaussianNB
classificador_SVC = SVC()
classificador_naive_bayes =  GaussianNB()

# definindo as entradas e saídas do conjunto de treino
treino_x = treino.drop('Outcome', axis=1) # remove a coluna Outcome do conjunto de dados de treino
treino_y = treino['Outcome'] # seleciona apenas a coluna Outcome

# treina os classificadores usando a função .fit(), ela ajusta o modelo aos dados de treinamento
# utilizando treino_x como as entradas e treino_y como as saidas
classificador_SVC.fit( treino_x, treino_y)
classificador_naive_bayes.fit( treino_x, treino_y)


# definindo as entradas e saídas do conjunto de teste
teste_x = teste.drop('Outcome', axis=1) # remove a coluna Outcome do conjunto de dados de teste
teste_y = teste['Outcome'] # seleciona apenas a coluna Outcome

# Avaliando os classificadores no conjunto de testes:

# Fazendo previsões nos casos de teste através do método .predict()
previ_svc = classificador_SVC.predict(teste_x)
previ_nb = classificador_naive_bayes.predict(teste_x)


from sklearn.metrics import precision_score, recall_score, f1_score

# avaliando os classificadores usando as métricas de avaliação precision, recall e F1-score

# precision_score calcula a proporção de instâncias classificadas como positivas que são realmente positivas
precision_svc = precision_score(teste_y, previ_svc)
precision_nb = precision_score(teste_y, previ_nb)

# recall_score calcula a proporção de instâncias positivas que foram identificadas corretamente pelo modelo
recall_svc = recall_score(teste_y, previ_svc)
recall_nb = recall_score(teste_y, previ_nb)

# f1_score calcula a média harmônica entre precision e recall
f1_svc = f1_score(teste_y, previ_svc)
f1_nb = f1_score(teste_y, previ_nb)

# Impressão das métricas de avaliação dos classificadores SVM e Naive Bayes no conjunto de teste
print("Métricas de avaliação dos classificadores:")
print(f"SVM-Precision: {precision_svc:.2f}   Recall: {recall_svc:.2f}    F1: {f1_svc:.2f}")
print(f"Naive Bayes-Precision: {precision_nb:.2f}   Recall: {recall_nb:.2f}   F1: {f1_nb:.2f}")
print("")

# Predição para as 3 primeiras instâncias do conjunto de teste
teste_3instancias = teste.iloc[:3] # o método iloc seleciona as 3 primeiras instancias do conjunto de teste
instancias_x = teste_3instancias.drop('Outcome', axis=1) # remove a coluna Outcome para utilizar as 3 instancias 
                                                         # como entrada para os classificadores

# faz a predição do atributo 'Outcome'(que indica se  o paciente tem ou não diabetes)  
# para as 3 primeiras instancias do conjunto teste usando os classificadores treinados
instancias_svc_previ = classificador_SVC.predict(instancias_x)
instancias_nb_previ = classificador_naive_bayes.predict(instancias_x)

print("Resultado das predições:")
# loop para percorrer as 3 primeiras instancias
for i in range(len(teste_3instancias)):
  # printa o resultado das predições
  print(f"Instancia {i+1}  SVM:{instancias_svc_previ[i]}  Naive Bayes:{instancias_nb_previ[i]}")